<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quackable!</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+HK:wght@300;400;500;700&family=Zen+Maru+Gothic:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #D4A373; /* Warm Sand */
            --primary-hover: #C59262;
            --bg: #FAFAF9; /* Off-white/Cream */
            --card-bg: #FFFFFF;
            --text-main: #4A4A4A; /* Soft Black */
            --text-sec: #8D8D8D;
            --accent: #A5A58D; /* Sage Green */
            --danger: #E6B8A2; /* Soft Red/Pink */
            --border: #E5E5E5;
        }

        body {
            font-family: 'Zen Maru Gothic', 'Noto Sans HK', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* No scrolling needed horizontal */
        }

        .container {
            background: var(--card-bg);
            width: 100%;
            max-width: 1000px;
            margin: 20px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            padding: 40px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
        }

        .header-left h1 {
            font-size: 1.8rem;
            margin: 0;
            color: var(--text-main);
            font-weight: 700;
            letter-spacing: 0.05em;
        }

        .header-left .subtitle {
            color: var(--text-sec);
            font-size: 0.9rem;
            margin-top: 5px;
            font-weight: 300;
        }

        .header-right .logo {
            height: 40px;
            cursor: pointer;
        }

        .header-right .about-btn {
            background: none;
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 5px 15px;
            cursor: pointer;
            color: var(--text-sec);
            font-family: inherit;
            transition: all 0.2s;
        }
        .header-right .about-btn:hover {
            color: var(--primary);
            border-color: var(--primary);
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
        }
        
        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Left Column: Controls & Challenge */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .word-card {
            background: #FFF;
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            position: relative;
            box-shadow: 0 2px 10px rgba(0,0,0,0.02);
        }

        .refresh-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-sec);
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.3s;
        }
        .refresh-btn:hover {
            transform: rotate(180deg);
            color: var(--primary);
        }

        .target-word {
            font-size: 3.5rem;
            font-weight: 500;
            margin: 10px 0;
            color: var(--text-main);
        }

        .jyutping {
            font-size: 1.2rem;
            color: var(--primary);
            font-weight: 400;
            font-family: 'Zen Maru Gothic', monospace;
        }

        .meaning {
            color: var(--text-sec);
            margin-top: 5px;
            font-size: 0.9rem;
            font-weight: 300;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn-main {
            background: var(--text-main);
            color: white;
            border: none;
            padding: 15px 20px;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn-main:hover {
            background: #333;
            transform: translateY(-1px);
        }
        
        .btn-main:disabled {
            background: #E5E5E5;
            cursor: not-allowed;
            color: #999;
            transform: none;
        }

        .btn-main.recording {
            background: var(--danger);
            color: #5d4037;
            animation: pulse 2s infinite;
        }
        
        .btn-sub {
            background: var(--bg);
            color: var(--text-main);
            border: 1px solid var(--border);
        }
        .btn-sub:hover {
            background: #EFEFEF;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(230, 184, 162, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(230, 184, 162, 0); }
            100% { box-shadow: 0 0 0 0 rgba(230, 184, 162, 0); }
        }
        
        .status {
            text-align: center;
            color: var(--text-sec);
            font-size: 0.8rem;
            font-weight: 300;
        }

        /* Right Column: Visualization */
        .viz-panel {
            position: relative;
            background: white;
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 480px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        #spectrogramCanvas {
            z-index: 10;
        }
        
        #f0Canvas {
            z-index: 20;
            pointer-events: none; /* Let clicks pass through if needed */
        }
        
        .viz-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .toggle-btn {
            background: none;
            border: none;
            color: var(--text-sec);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .toggle-btn:hover {
            background: #f5f5f5;
        }
        
        .toggle-btn.active {
            color: var(--primary);
            background: rgba(212, 163, 115, 0.1);
            font-weight: 600;
        }

        .ref-controls {
            display: flex;
            align-items: center;
            background: #f1f1f1;
            border-radius: 20px;
            padding: 4px;
        }
        
        .ref-controls .toggle-btn {
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 0.85rem;
            color: var(--text-sec);
            background: transparent;
            margin: 0;
            gap: 0;
        }
        
        .ref-controls .toggle-btn:hover {
            background: rgba(255,255,255,0.5);
        }
        
        .ref-controls .toggle-btn.active {
            background: white;
            color: var(--primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-weight: 600;
        }
        
        .ref-controls span {
             display: none; 
        }

        #transcript-overlay {
            position: absolute;
            bottom: 0px; 
            left: 0;
            width: 100%;
            height: 30px;
            pointer-events: none;
            z-index: 30;
        }
        
        .char-label {
            position: absolute;
            bottom: 0;
            transform: translateX(-50%);
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-main);
            background: rgba(255,255,255,0.7);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* Modal */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.4); 
            backdrop-filter: blur(2px);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; 
            padding: 30px;
            border: 1px solid #888;
            width: 80%; 
            max-width: 500px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        
        .typeduck-promo {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        .typeduck-logo {
            font-weight: bold;
            color: #FCBF49;
        }
        
        /* Guide lines */
        .syllable-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <h1>Quackable</h1>
                <div class="subtitle">Tone Practice ËÅ≤Ë™øÁ∑¥Áøí</div>
            </div>
            <div class="header-right">
                <button class="about-btn" onclick="openAbout()">About</button>
            </div>
        </header>

        <div class="content-grid">
            <!-- Left Panel -->
            <div class="left-panel">
                <div class="word-card">
                    <button class="refresh-btn" onclick="updateRandomWord()" title="Next Word">‚Üª</button>
                    <h2 class="target-word" id="targetWord">‰Ω†Â•Ω</h2>
                    <div class="jyutping" id="targetJyutping">nei5 hou2</div>
                    <div class="meaning" id="targetMeaning">Hello</div>
                </div>
                
                <div class="controls">
                    <button id="recordBtn" class="btn-main" onclick="toggleRecording()">
                        <span>üéôÔ∏è Record / ÈåÑÈü≥</span>
                    </button>
                    <button id="playBtn" class="btn-main btn-sub" onclick="playAudio()" disabled>
                        <span>‚ñ∂Ô∏è Playback / ÈáçÊí≠</span>
                    </button>
                    <div class="status" id="status">Ready to start / Ê∫ñÂÇôÈñãÂßã</div>
                </div>

                <div style="margin-top: 20px; text-align: center; color: var(--text-sec); font-size: 0.9em;">
                    <p>Powered by <span style="font-weight: bold; color: var(--text-main);">TypeDuck</span></p>
                    <a href="https://typeduck.hk" target="_blank" style="color: var(--primary); text-decoration: none;">Download TypeDuck Keyboard</a>
                </div>
            </div>

            <!-- Right Panel: Visualization -->
            <div class="viz-panel">
                <div class="viz-controls">
                    <button class="toggle-btn active" onclick="toggleSpectrogram()" id="specToggle">
                        <span>üåä Spectrogram</span>
                    </button>
                    <div class="ref-controls">
                         <span style="font-size:0.8rem; color:var(--text-sec); margin-right:5px;">Ref:</span>
                         <button class="toggle-btn" onclick="setRef('M')" id="refM">Male</button>
                         <button class="toggle-btn" onclick="setRef('F')" id="refF">Female</button>
                         <button class="toggle-btn active" onclick="setRef(null)" id="refNone">Off</button>
                    </div>
                </div>
                
                <div class="canvas-container">
                    <!-- Layers -->
                    <canvas id="spectrogramCanvas"></canvas>
                    <div id="syllableOverlay" class="syllable-lines"></div>
                    <canvas id="f0Canvas"></canvas>
                    <div id="transcript-overlay"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAbout()">&times;</span>
            <h2>About Quackable</h2>
            <p>Idea by <strong>Ann To</strong></p>
            <p>Created by:</p>
            <p><strong>Chaak-ming Lau</strong> (chaak.net)</p>
            <p>&</p>
            <p><strong>Gemini 3 Pro</strong></p>
            
            <div class="typeduck-promo">
                <p>Learn Cantonese typing with <span class="typeduck-logo">TypeDuck</span>!</p>
                <a href="https://typeduck.hk" target="_blank" style="color: var(--primary);">typeduck.hk</a>
            </div>
        </div>
    </div>

    <script src="words.js"></script>
    <script>
        // Data & State
        // Used from words.js
        const words = typeof practiceWords !== 'undefined' ? practiceWords : [
            { word: "‰Ω†Â•Ω", jp: "nei5 hou2", en: "Hello" } // Fallback
        ];

        let audioContext;
        let mediaRecorder;
        let audioChunks = [];
        let audioBuffer;
        let isRecording = false;
        let recognition;
        let transcriptResult = "";
        let showSpectrogram = true;
        let refGender = null; // 'M' or 'F' or null
        const MAX_DURATION = 3000;

        // UI Functions
        function updateRandomWord() {
            const random = words[Math.floor(Math.random() * words.length)];
            document.getElementById('targetWord').textContent = random.word;
            document.getElementById('targetJyutping').textContent = random.jp;
            document.getElementById('targetMeaning').textContent = random.en;
            transcriptResult = ""; 
            clearViz();
        }

        function openAbout() { document.getElementById('aboutModal').style.display = 'block'; }
        function closeAbout() { document.getElementById('aboutModal').style.display = 'none'; }
        window.onclick = function(event) {
            if (event.target == document.getElementById('aboutModal')) closeAbout();
        }

        function toggleSpectrogram() {
            showSpectrogram = !showSpectrogram;
            document.getElementById('spectrogramCanvas').style.opacity = showSpectrogram ? 1 : 0;
            document.getElementById('specToggle').classList.toggle('active');
        }

        function setRef(gender) {
            refGender = gender;
            ['refM','refF','refNone'].forEach(id => document.getElementById(id).classList.remove('active'));
            if(gender === 'M') document.getElementById('refM').classList.add('active');
            else if(gender === 'F') document.getElementById('refF').classList.add('active');
            else document.getElementById('refNone').classList.add('active');
            
            // Redraw F0 if buffer exists
            if(audioBuffer) drawF0Contour(audioBuffer);
        }

        // Initialize
        window.onload = function() {
            updateRandomWord();
            setupASR();
        };

        function setupASR() {
             if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'yue-Hant-HK'; 
                recognition.continuous = false;
                recognition.interimResults = false;
                
                recognition.onresult = (event) => {
                    transcriptResult = event.results[0][0].transcript;
                    // Will render later after audio processing
                };
            }
        }

        // Recording & Audio Processing
        async function toggleRecording() {
            if (!isRecording) await startRecording();
            else stopRecording();
        }

        async function startRecording() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => {
                   const blob = new Blob(audioChunks, { type: 'audio/wav' });
                   await processAudio(blob);
                   stream.getTracks().forEach(t => t.stop());
                };

                mediaRecorder.start();
                if (recognition) {
                    try { recognition.start(); } catch(e){}
                }
                
                isRecording = true;
                const btn = document.getElementById('recordBtn');
                btn.classList.add('recording');
                btn.querySelector('span').textContent = "‚èπÔ∏è Stop / ÂÅúÊ≠¢";
                document.getElementById('status').textContent = "Recording... / ÈåÑÈü≥‰∏≠";
                
                setTimeout(() => { if(isRecording) stopRecording(); }, MAX_DURATION);
                
            } catch (err) {
                alert("Microphone access required / ÈúÄË¶ÅÈ∫•ÂÖãÈ¢®Ê¨äÈôê");
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                if (recognition) recognition.stop();
                isRecording = false;
                
                const btn = document.getElementById('recordBtn');
                btn.classList.remove('recording');
                btn.querySelector('span').textContent = "üéôÔ∏è Record / ÈåÑÈü≥";
                document.getElementById('status').textContent = "Processing... / ËôïÁêÜ‰∏≠";
            }
        }

        async function processAudio(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const rawBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Trim silence
            audioBuffer = trimSilence(rawBuffer);
            
            if (audioBuffer.length > 0) {
                 // Resize canvases to match CSS display size for sharp text
                 const container = document.querySelector('.canvas-container');
                 const displayW = container.clientWidth;
                 const displayH = container.clientHeight;
                 
                 ['spectrogramCanvas', 'f0Canvas'].forEach(id => {
                     const c = document.getElementById(id);
                     c.width = displayW; 
                     c.height = displayH;
                 });

                 drawSpectrogram(audioBuffer); // Also calculates syllables
                 drawF0Contour(audioBuffer);
                 renderTranscript(audioBuffer);
                 document.getElementById('playBtn').disabled = false;
                 document.getElementById('status').textContent = "Done / ÂÆåÊàê";
            } else {
                 document.getElementById('status').textContent = "No voice detected / Êú™ÂÅµÊ∏¨Âà∞ËÅ≤Èü≥";
            }
        }

        // Signal Processing & Viz
        function trimSilence(buffer) {
            // Simple RMS VAD
            const data = buffer.getChannelData(0);
            const frameSize = Math.floor(buffer.sampleRate * 0.01);
            let maxE = 0;
            const energies = [];
            
            for(let i=0; i<data.length; i+=frameSize) {
                let s = 0;
                for(let j=0; j<frameSize && i+j<data.length; j++) s+= data[i+j]**2;
                const rms = Math.sqrt(s/frameSize);
                energies.push(rms);
                if(rms>maxE) maxE = rms;
            }
            
            const thresh = Math.max(0.005, maxE * 0.1); 
            let start = 0, end = energies.length - 1;
            while(start < energies.length && energies[start] < thresh) start++;
            while(end > start && energies[end] < thresh) end--;
            
            if(start >= end) return {length:0}; // Empty

            const pad = Math.floor(0.15 * buffer.sampleRate); // 150ms padding
            const startSamp = Math.max(0, start * frameSize - pad);
            const endSamp = Math.min(data.length, end * frameSize + pad);
            
            const newBuff = audioContext.createBuffer(1, endSamp - startSamp, buffer.sampleRate);
            newBuff.copyToChannel(data.slice(startSamp, endSamp), 0);
            return newBuff;
        }

        function drawSpectrogram(buffer) {
            const canvas = document.getElementById('spectrogramCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            ctx.clearRect(0,0,w,h);
            
            const data = buffer.getChannelData(0);
            const fftSize = 2048, hopSize = 256; // Higher resolution
            const numFrames = Math.floor((data.length - fftSize)/hopSize);
            
            // Calc Spectrogram
            const specs = [];
            let maxM = 0;
            for(let i=0; i<numFrames; i++) {
                const frame = data.slice(i*hopSize, i*hopSize+fftSize);
                const spec = computeFFT(frame);
                specs.push(spec);
                for(let v of spec) if(v>maxM) maxM = v;
            }
            
            // Draw
            const maxFreq = 5000;
            const bins = Math.floor(maxFreq / (buffer.sampleRate/2) * (fftSize/2));
            
            // Create offscreen buffer for speed
            const imgData = ctx.createImageData(w, h);
            
            for(let x=0; x<w; x++) {
                const frameIdx = Math.floor(x/w * numFrames);
                if(frameIdx >= specs.length) break;
                const spec = specs[frameIdx];
                
                for(let y=0; y<h; y++) {
                    const binIdx = Math.floor((h-1-y)/h * bins);
                    const mag = spec[binIdx];
                    const dB = 20*Math.log10((mag+1e-6)/(maxM+1e-6));
                    // Range -50dB to 0dB
                    const val = Math.max(0, Math.min(255, 255 * (1 - (dB + 50)/50)));
                    
                    const pIdx = (y*w + x)*4;
                    imgData.data[pIdx] = val;   // R
                    imgData.data[pIdx+1] = val; // G
                    imgData.data[pIdx+2] = val; // B
                    imgData.data[pIdx+3] = 255; // Alpha
                }
            }
            ctx.putImageData(imgData, 0, 0);

            // Draw Frequency Grid
            ctx.fillStyle = 'black';
            ctx.font = '10px sans-serif';
            ctx.textBaseline = 'top';
            for(let f=1000; f<maxFreq; f+=1000) {
                const y = h - (f/maxFreq)*h;
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(0,y,w,1);
                ctx.fillStyle = '#999';
                ctx.fillText(f/1000 + 'k', 5, y);
            }
            
            detectSyllables(specs, w);
        }

        function detectSyllables(specs, width) {
            // Syllable segmentation: Peak finding + Mid-point split
            const energyProfile = specs.map(s => {
                let sum = 0;
                for(let k=0; k<100 && k<s.length; k++) sum += s[k]; // 0-2kHz roughly
                return sum;
            });
            
            // Smooth
            const smoothed = [];
            const win = 15;
            for(let i=0; i<energyProfile.length; i++) {
                let s=0, c=0;
                for(let j=-win; j<=win; j++) {
                    if(i+j>=0 && i+j<energyProfile.length) { s+=energyProfile[i+j]; c++; }
                }
                smoothed.push(s/c);
            }
            
            const overlay = document.getElementById('syllableOverlay');
            overlay.innerHTML = '';
            
            const maxE = Math.max(...smoothed);
            const silenceThresh = maxE * 0.15;
            
            // 1. Identify "Active Regions" (above threshold) = Syllable cores
            let active = false;
            let currentRegion = {start:0, end:0, maxIdx:0, maxVal:0};
            const regions = [];
            
            for(let i=0; i<smoothed.length; i++) {
                if(smoothed[i] > silenceThresh) {
                    if(!active) {
                        active = true;
                        currentRegion = {start:i, end:i, maxIdx:i, maxVal:smoothed[i]};
                    } else {
                        if(smoothed[i] > currentRegion.maxVal) {
                             currentRegion.maxVal = smoothed[i];
                             currentRegion.maxIdx = i;
                        }
                        currentRegion.end = i;
                    }
                } else {
                    if(active) {
                        active = false;
                        if(currentRegion.end - currentRegion.start > 10) { // Min width check
                             regions.push(currentRegion);
                        }
                    }
                }
            }
            if(active && currentRegion.end - currentRegion.start > 10) regions.push(currentRegion);
            
            // 2. Find boundaries BETWEEN distinct active regions (Syllables)
            // The boundary should be the minimum energy point between Region A and Region B
            const splitPoints = [];
            
            for(let k=0; k<regions.length-1; k++) {
                const r1 = regions[k];
                const r2 = regions[k+1];
                
                // Search for global min between r1.maxIdx and r2.maxIdx
                // Actually, let's search between r1.end and r2.start first?
                // The gap might be small. 
                
                // Let's look for the deepest valley between the two peaks
                let searchStart = r1.maxIdx;
                let searchEnd = r2.maxIdx;
                let minVal = Infinity;
                let minIdx = -1;
                
                for(let m=searchStart; m<=searchEnd; m++) {
                    if(smoothed[m] < minVal) {
                        minVal = smoothed[m];
                        minIdx = m;
                    }
                }
                
                splitPoints.push(minIdx);
            }
            
            // 3. Draw lines at split points (skip end/start)
            // Just draws the dividers
            splitPoints.forEach(frameIdx => {
                const pct = (frameIdx / specs.length) * 100;
                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.left = pct + '%';
                line.style.top = '0';
                line.style.height = '100%';
                line.style.borderLeft = '1px dashed rgba(0,0,0,0.3)';
                overlay.appendChild(line);
            });
            
            window.lastBoundaries = splitPoints; // For text placement
        }

        function drawF0Contour(buffer) {
            const canvas = document.getElementById('f0Canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
            
            const data = buffer.getChannelData(0);
            const sr = buffer.sampleRate;
            const hopSize = Math.floor(sr*0.01); // 10ms
            const numFrames = Math.floor(data.length/hopSize);
            
            const minF0 = 20, maxF0 = 320;
            const h = canvas.height, w = canvas.width;
            
            // Draw Reference Lines
            if(refGender) {
                const refHigh = refGender === 'M' ? 180 : 250; // T1
                const refLow = refGender === 'M' ? 50 : 80;    // T4
                
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                
                // Low Line
                const yLow = h - (refLow-minF0)/(maxF0-minF0)*h;
                if(yLow >= 0 && yLow <= h) {
                    ctx.strokeStyle = '#81C784'; // Greenish
                    ctx.beginPath(); ctx.moveTo(0, yLow); ctx.lineTo(w, yLow); ctx.stroke();
                    ctx.fillStyle = '#81C784'; ctx.fillText("T4", 5, yLow-2);
                }
                
                // High Line
                const yHigh = h - (refHigh-minF0)/(maxF0-minF0)*h;
                if(yHigh >= 0 && yHigh <= h) {
                    ctx.strokeStyle = '#FFB74D'; // Orangeish
                    ctx.beginPath(); ctx.moveTo(0, yHigh); ctx.lineTo(w, yHigh); ctx.stroke();
                    ctx.fillStyle = '#FFB74D'; ctx.fillText("T1", 5, yHigh-2);
                }
                ctx.restore();
            }

            // Draw Right Axis (Pitch)
            ctx.save();
            ctx.fillStyle = '#2196F3'; 
            ctx.strokeStyle = 'rgba(33, 150, 243, 0.5)'; 
            ctx.font = '12px sans-serif'; 
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const axisX = w - 40; 
            ctx.beginPath();
            ctx.moveTo(axisX, 0); 
            ctx.lineTo(axisX, h); 
            ctx.stroke();
            
            // Draw ticks every 50Hz starting from 50
            for(let f=50; f<=300; f+=50) {
                 const y = h - (f-minF0)/(maxF0-minF0)*h;
                 ctx.fillText(f, w-5, y);
                 ctx.beginPath(); 
                 ctx.moveTo(axisX, y); 
                 ctx.lineTo(axisX+5, y); 
                 ctx.stroke();
            }
            ctx.restore();

            // Calculate Points
            const points = [];
            for(let i=0; i<numFrames; i++) {
                const frame = data.slice(i*hopSize, i*hopSize+2048);
                if(frame.length < 100) break;
                
                // VAD check
                let e = 0; 
                for(let s of frame) e+=s*s;
                e = Math.sqrt(e/frame.length);
                if(e < 0.01) { points.push(null); continue; }

                const f0 = detectPitch(frame, sr);
                if(f0 > minF0 && f0 < maxF0) {
                    points.push({f0, i});
                } else {
                    points.push(null);
                }
            }
            
            // 1. Draw Line (Smoothed)
            ctx.strokeStyle = '#2196F3'; 
            ctx.lineWidth = 3; 
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            let lastY = -1;
            let lastF0 = -1;
            let hasStart = false;

            points.forEach((p, idx) => {
                const x = (idx/numFrames)*w;
                if(p) {
                    const y = h - (p.f0-minF0)/(maxF0-minF0)*h;
                    
                    // Continuity Check:
                    // If we have a previous point, check if the change is "rapid"
                    // Threshold: 30Hz difference between 10ms frames?
                    const isContinuous = hasStart && Math.abs(p.f0 - lastF0) < 40;

                    if(isContinuous) {
                        ctx.lineTo(x,y);
                    } else {
                        ctx.moveTo(x,y);
                        hasStart = true;
                    }
                    lastY = y;
                    lastF0 = p.f0;
                } else {
                    hasStart = false;
                }
            });
            ctx.stroke();

            // 2. Draw Dots
            ctx.fillStyle = '#C2185B'; // Deep Pink/Red
            points.forEach((p, idx) => {
                if(p) {
                    const x = (idx/numFrames)*w;
                    const y = h - (p.f0-minF0)/(maxF0-minF0)*h;
                    
                    // Show dots only if safe (not chaotic jump)
                    // Or strict 10ms sampling visualization
                    ctx.beginPath();
                    ctx.arc(x, y, 1.5, 0, 2*Math.PI); // Radius 1.5
                    ctx.fill();
                }
            });
        }

        function renderTranscript(buffer) {
            const overlay = document.getElementById('transcript-overlay');
            overlay.innerHTML = '';
            
            const targetWord = document.getElementById('targetWord').textContent;
            
            // Only show if ASR matched perfectly to avoid alignment mess with wrong text
            // Or if transcript is non-empty, try to distribute char by char.
            // Requirement 4: "display individual characters ... if ASR detects exact same thing"
            
            // Clean transcript (remove dots)
            const cleanTrans = transcriptResult.replace(/[.,!?]/g, '');
            
            if (cleanTrans === targetWord) {
                // Distribute characters based on detected syllables/energy blobs
                // Simplest: Evenly distribute over valid voice regions?
                // Better: Use the 'boundaries' from detectSyllables.
                
                // Let's reuse detectSyllables logic or approximating
                // For a 2 char word, split buffer in half? 
                
                // Let's assume eqi-distant for now as simple fallback since JS DSP segmentation is hard
                const chars = cleanTrans.split('');
                const step = 100 / chars.length;
                
                chars.forEach((char, i) => {
                    const span = document.createElement('span');
                    span.className = 'char-label';
                    span.textContent = char;
                    span.style.left = (step * i + step/2) + '%';
                    overlay.appendChild(span);
                });
            } else {
                 // Show full transcript at bottom status if mismatch
                 const span = document.createElement('span');
                 span.className = 'char-label';
                 span.style.width = '100%';
                 span.style.left = '50%'; // Centered
                 span.style.background = 'none';
                 span.style.fontSize = '14px';
                 span.style.color = '#d32f2f';
                 span.textContent = "Heard: " + (transcriptResult || "...");
                 overlay.appendChild(span);
            }
        }

        // --- Helpers ---
        function computeFFT(sig) {
            // Very simplified magnitude spectrum
            // Real impl would skip this for WebAudio AnalyserNode but we need sync access
            // Hacky DFT for visualization
            const N = sig.length;
            const res = new Float32Array(N/2);
            // Optimization: Only compute every 4th bin or so for Viz? No, modern JS is fast enough for 1024
            
            // Precompute window
            if(!window.hann) {
                 window.hann = new Float32Array(N);
                 for(let i=0;i<N;i++) window.hann[i] = 0.5 * (1 - Math.cos(2*Math.PI*i/(N-1)));
            }
            
            const real = new Float32Array(N/2);
            const imag = new Float32Array(N/2);
            
            for(let i=0; i<N; i++) {
                const s = sig[i] * window.hann[i];
                for(let k=0; k<N/2; k++) {
                   const a = -2*Math.PI*k*i/N;
                   real[k] += s * Math.cos(a);
                   imag[k] += s * Math.sin(a);
                }
            }
            
            for(let k=0; k<N/2; k++) res[k] = Math.sqrt(real[k]**2 + imag[k]**2);
            return res;
        }

        function detectPitch(sig, sr) {
             // NAC-like
             const minDelay = Math.floor(sr/400); // ~400Hz
             const maxDelay = Math.floor(sr/70);  // ~70Hz
             
             let maxR = 0; 
             let bestT = 0;
             
             const N = sig.length;
             // Search in range
             for(let T=minDelay; T<maxDelay; T++) {
                 let num=0, den1=0, den2=0;
                 // Sum over a window W
                 const W = Math.min(1024, N-T);
                 for(let i=0; i<W; i+=2) { // 2x decimation for speed
                     num += sig[i] * sig[i+T];
                     den1 += sig[i]**2;
                     den2 += sig[i+T]**2;
                 }
                 if(den1*den2 === 0) continue;
                 const R = num / Math.sqrt(den1*den2);
                 if(R > maxR) { maxR = R; bestT = T; }
             }
             
             if(maxR < 0.60) return 0; // Stricter unvoiced threshold for fricatives
             return sr/bestT;
        }

        function playAudio() {
            if(!audioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = audioBuffer;
            src.connect(audioContext.destination);
            src.start();
        }
        
        function clearViz() {
             const c1 = document.getElementById('spectrogramCanvas');
             const c2 = document.getElementById('f0Canvas');
             c1.getContext('2d').clearRect(0,0,c1.width,c1.height);
             c2.getContext('2d').clearRect(0,0,c2.width,c2.height);
             document.getElementById('transcript-overlay').innerHTML = "";
             document.getElementById('syllableOverlay').innerHTML = "";
             document.getElementById('playBtn').disabled = true;
             document.getElementById('status').textContent = "Ready";
        }

    </script>
</body>
</html>